# 分享

> 浏览器内核主要包括以下三个技术分支：Rendering Engine、 JavaScript engine，以及其他。

本文大致脉络：现阶段遇到的问题->微前端的解决方案->微前端的理论支持->遇到的问题。

### 概述

一般面试喜欢问，从输入一段url到页面展示，这个过程发生了什么。这是个很经典的面试问题，细说说个三天三夜都说不完，从中可以看出一个前端工程师对网络工程、浏览器、前端工程等各个角度的理解，还有个人方向的深入程度。我也抛出一个问题，作为本文的核心内容。

**以vue为例，从你写完一个带路由的spa项目并打包部署再到浏览器呈现，这个过程发生了什么？**

前提：默认有`pageA`组件跟`pageB`组件，项目支持es module，实现按需加载。

- 开始build之后，经由babel、webpack或者其他编译器，不管你写的文件是.vue还是.jsx还是.tsx，甚至wxml、wxss，总之一顿操作，把你的整个项目编译成三个包，html\css\js。

  因为是单页应用，所以最终只有一个html。js因为要code-splite，在路由变化的时候加载不同资源，会分别打包成chunk~pageA.js、chunk~pageB.js，还有一些乱七八糟的公共组件，比如后台项目常见的layout，loading之类，以及公共依赖如vue、react或多次使用的工具函数等。

- 



首先讲一下微前端的概念，最近微前端征文，很少看到有讲到概念层面的东西，大多数是一些前端框架的实践，demo之类，感觉对小白不是很友好，让人看得一头雾水。有的人说小程序是微前端，有的人说qiankun是微前端，那到底微前端是啥？是一种概念？还是一种架构？一种框架？正好本人在公司有做类似的实践，谈一谈本人对微前端的理解，献丑做个抛砖引玉。

广义的微前端：

刚刚说完狭义的微前端，很明显有的人会觉得不对劲，发出灵魂拷问疑问：~~就这？~~那iframe算不算微前端？如果把iframe也算在微前端里，小程序算不算？公众号算不算？先回答，当然算，且听我慢慢道来。

要理解广义上的微前端，就得先知道什么是前端，正如想做一盘牛排，我们先得学会如何接生小牛崽一样。

这里的前端，指的是web前端，简单点讲，前端工程师把HTML、JavaScript、CSS这“三驾马车”作为输入，经过WebKit的处理，就输出成了我们能看到以及操作的Web页面。WebKit是一个页面渲染以及逻辑处理引擎，下面是偷的两幅webkit架构图（《[认识V8引擎](https://zhuanlan.zhihu.com/p/27628685)》，《[深入理解JSCore](https://tech.meituan.com/2018/08/23/deep-understanding-of-jscore.html)》），很直接明确，有眼睛就能看懂，在此不赘述。

![preview](https://pic4.zhimg.com/v2-959135939fe2cbc2d9a437ef81dff328_r.jpg)

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/c718ac49.png)

理论上来说，只要有渲染引擎就可以完整地把js+html+css组成的页面呈现到页面上，渲染引擎有Tridend(IE)、Gecko(FF)、WebKit(Safari,Chrome,Andriod浏览器)等。WebKit是由苹果2005年发起的一个开源项目，引起了众多公司的重视，几年间被很多公司所采用，在移动端更占据了垄断地位。

想想我们熟悉的chrome浏览器，标签页之间的页面是不是隔离的，支持页面的代码是不是都是html+css+js。其实我们看看chrome的架构或者打开任务管理器就会知道，每个浏览器窗口都有1个浏览器主进程**、**1个GPU进程**、**1个网络进程、和多个插件进程、**多个渲染进程对应不同标签页（不完全是，iframe在chrome中也会单独起进程）**。每个标签页中的context（比如vuex、redux中你设定好的全局变量，chrome会将其存在内存中，由进程管理）都是完全隔离的，但又要与父容器有通信，可控（比如历史记录、钥匙串之类）。是不是很熟悉，跟微前端很像，所以我把这种模式的微前端称之为广义上的微前端。

引申解释：为什么小程序也算微前端，因为小程序是跑在native的h5容器中的，通过自定义的dsl（WXML+WXS的组合）书写-即渲染引擎不同，结果同样是 HTML/CSS/JS 显示在 webview 上。

## 总结

广义的微前端定义：

- 渲染引擎一致即容器内底层支持一致。
- 可以支持运行多个子应用，为每个应用起一个单独进程，独立context。

狭义微前端的定义：

- web应用中的一个js模块，可以是另一个web应用，也可以是一个组件，一个函数。

殊途同归，广义上的微前端大多是为了支持

> 对于这块，[bang 的博客](https://link.zhihu.com/?target=http%3A//blog.cnbang.net/tech/3486/) 从需求分析技术方案分析的很不错，在小程序出来之前，各大平台是怎么解决开放问题的呢，大都通过纯 H5 应用来实现开放，平台提供 H5 容器，并通过 jsapi 提供 Native 接口，第三方开发者开发 H5 应用并调用平台提供的接口，然后将 H5 应用嵌入到平台中，也可以使用平台提供的各方面能力。 这种方案有以下几个主要问题： *平台对纯 H5 应用缺乏管控，开发者几乎可以随意改变应用，平台对这块的管控非常困难，作为平台如果没有管控能力是很危险的* 纯 H5 应用体验太差，无论是启动速度还是页面渲染速度都与 Native 相去甚远

基于这点微前端就是容器化的概念，类似k8s，由父容器与子容器组成，父容器管理子容器，父子可通信（数据通信，样式通信=>比如modal，但偶尔也会需要样式隔离，比如webIDE，此时就需要iframe，据说web-component也能实现这种需求）。在不同环境，保证父容器一致，子容器中跑同一套代码就是可以实现的。

狭义的微前端：

>  In the context of single-spa, a microfrontend is often an in-browser JavaScript module 
>
> 微前端是浏览器内的javascript模块。  -single-spa官网定义

这种微前端，single-spa将其分为了三种：Application（应用程序）、Parcel（沙箱）、Utility（公共模块）



|          | Application（应用程序） | Parcel（包） | Utility      |
| -------- | ----------------------- | ------------ | ------------ |
| 路由     | 有多个路由              | 无           | 无           |
| API      | 声明式API               | 必要API      | 提供接口     |
| 渲染UI   | 有                      | 有           | 不直接渲染UI |
| 生命周期 | single-spa管理生命周期  |              |              |
| 何时使用 |                         |              |              |



### 

参考资料：

- 《认识 V8 引擎》：https://zhuanlan.zhihu.com/p/27628685
- 



