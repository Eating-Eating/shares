# 分享

> 浏览器内核主要包括以下三个技术分支：Rendering Engine、 JavaScript engine，以及其他。

### 微前端

首先讲一下微前端的概念，最近微前端征文，很少看到有讲到概念层面的东西，大多数是一些前端框架的实践，demo之类，感觉对小白不是很友好，让人看得一头雾水。有的人说小程序是微前端，有的人说qiankun是微前端，那到底微前端是啥？是一种概念？还是一种架构？一种框架？正好本人在公司有做类似的实践，谈一谈本人对微前端的理解，献丑做个抛砖引玉。

广义的微前端：

理论上来说，只要有renderding engine跟js engine就可以完整地把js+html+css组成的页面呈现到终端上。基于这点微前端本质上就是容器化的概念，类似k8s，由父容器与子容器组成，父容器管理子容器，父子可通信（数据通信，样式通信=>比如modal，但偶尔也会需要样式隔离，比如webIDE，此时就需要iframe，据说web-component也能实现这种需求）。在不同环境，保证父容器一致，子容器中跑同一套代码就是可以实现的。

由这种概念，引申出了许多中微前端的实践，大致分为两种思路，一种是为了跑在多端的代码，爆改父容器（浏览器）使其可控，有时候需要爆改标签语言（html）、脚本语言（js）使其符合父容器的渲染引擎的要求，比如微信小程序（WXML+WXS的组合），或者h5混合式开发（webview->webkit内核），通过jsBridge进行通信。还有一种，就是为了拆分巨石应用，不局限于同一技术栈，由父容器接入管理不同子应用，比如single-spa。这就是微前端的核心概念。

狭义的微前端：

>  In the context of single-spa, a microfrontend is often an in-browser JavaScript module 
>
> 微前端是浏览器内的javascript模块。  -single-spa官网定义

这种微前端，single-spa将其分为了三种：Application（应用程序）、Parcel（沙箱）、Utility（公共模块）



|          | Application（应用程序） | Parcel（包） | Utility      |
| -------- | ----------------------- | ------------ | ------------ |
| 路由     | 有多个路由              | 无           | 无           |
| API      | 声明式API               | 必要API      | 提供接口     |
| 渲染UI   | 有                      | 有           | 不直接渲染UI |
| 生命周期 | single-spa管理生命周期  |              |              |
| 何时使用 |                         |              |              |



### BFF架构



> React-Native、Weex核心是通过Javascript开发，执行时需要Javascript解释器，UI是通过原生控件渲染。Flutter与用于构建移动应用程序的其它大多数框架不同，因为Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。Flutter使用C、C ++、Dart和Skia（2D渲染引擎）构建。在IOS上，Flutter引擎的C/C ++代码使用LLVM编译，任何Dart代码都是AOT编译为本地代码的，Flutter应用程序使用本机指令集运行（不涉及解释器）。而在Android下，Flutter引擎的C/C ++代码是用Android的NDK编译的，任何Dart代码都是AOT编译成本地代码的，Flutter应用程序依然使用本机指令集运行（不涉及解释器）。因此，Flutter能达到原生应用一样的性能。
>
> 同时，Flutter提供了一组自己的widget），由Flutter的framework和引擎管理和渲染。您可以浏览[Flutter widget](https://flutterchina.club/widgets/)的[目录](https://flutterchina.club/widgets/)。之所以不适用原生控件，是因为Flutter希望最终结果是更高质量的，如果Flutter使用原生系统widget，Flutter应用的质量和性能将受到这些widget本身质量的限制。例如，在Android中，有一组硬编码的手势和固定的规则来对它们进行手势冲突消歧。在Flutter中，您可以编写自己的手势识别器，该手势识别器是[手势系统](https://flutterchina.club/gestures/)中的一级参与者 。此外，由不同人撰写的两个小工具可协调手势冲突消歧。
>




> # Why Not Iframe
>
> 为什么不用 iframe，这几乎是所有微前端方案第一个会被 challenge 的问题。但是大部分微前端方案又不约而同放弃了 iframe 方案，自然是有原因的，并不是为了 "炫技" 或者刻意追求 "特立独行"。
>
> 
>
> *如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了。*
>
> *
> *
>
> iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。
>
> 
>
> *其实这个问题之前[这篇](https://yuque.antfin-inc.com/youzhi.lk/onex/titx2c)也提到过，这里再单独拿出来回顾一下好了。*
>
> 
>
> 1. url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
> 2. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
> 3. 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
> 4. 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。
>
> 
>
> 其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。